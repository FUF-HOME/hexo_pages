---
title: Database-索引
date: 2020-07-26 21:27:18
author: fuf
notebook: blog
evernote-version: 0
source: 原创/转载
thumbnail: 
tags:
    - DATABASE
blogexcerpt:
---

# 数据库

# MySQL 索引
**索引：根据特定的数据结构，以便于更快的找到所需要的数据。**

## 优点：
快速检索：减少 I/O 次数，加快检索速度，根据索引分组和排序，可以加快分组和排序。

## 缺点：
索引也是表，因此会占用存储空间，索引的维护和创建需要时间成本，这个成本随着数据量增大而增大。构建索引会降低数据表的修改操作(删除，添加，修改)的效率,因为在修改数据表的同时还需要修改索引表。

## 分类
在MySQL中，常见的索引类型有：
  1. 主键索引、
  2. 唯一索引、
  3. 普通索引、
  4. 全文索引、
  5. 组合索引.  

创建语法分别为：

```
alter table 'table_name' ADD PROMARY KEY pk_index('col');
alter table 'table_name' add unique index_name('col');
alter table 'table_name' add index index_name('col');
alter table 'table_name' add fulltext index ft_index('col');
alter table 'table_name' add index index_name('col1','col2','col3');

```
其中，组合索引又称为多列索引，上述代码中最后一个例子就是建立了3列的索引。MySQL在根据索引查询时，会遵循**“最左匹配”**原则，即先根据col1的条件查，再根据col2的条件查，然后再根据col3的条件去查。左优先，在检索数据时从联合索引的最左边开始匹配

## 索引的实现原理
MySQL的索引是由存储引擎来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。这里由于主要介绍BTree索引和B+Tree索引，我们平时使用最多的InnoDB引擎就是基于B+Tree索引的。

## BTree
BTree（又称为B-Tree）是一个平衡搜索多叉树。BTree的结构如下图：

设树的度为2d（d>1），高度为h，那么BTree有以下性质：
![](https://ws1.sinaimg.cn/large/007SLs93ly1g66zyzode6j30kj0ggdfz.jpg)

- 每个叶子结点的高度一样，等于h；
- 每个非叶子结点由n-1个key和n个指针组成，key和指针相互隔离，结点两端一定是key；
- 叶子结点指针为null；
- 非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的其它列的数据；

在BTree中，对索引列是顺序存储的，所以很适合查找范围数据和ORDER BY操作。

## B+Tree
B+Tree是BTree的一种变种。B+Tree和BTree的不同主要在于：
![](https://ws1.sinaimg.cn/large/007SLs93ly1g67030z7qmj30f305bdfs.jpg)
- B+Tree中的非叶子结点不存储数据，只存储键值；
- B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；
- B+Tree的每个非叶子节点由n个键值key和n个指针point组成；

### B+Tree对比BTree的优点：
一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构。  

磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找。  

已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。

### 带顺序索引的B+Tree
 一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。

## 聚簇索引和非聚簇索引
MySQL中最常见的两种存储引擎分别是MyISAM和InnoDB，分别实现了非聚簇索引和聚簇索引。  

前段时间看到一个问题：“你知道为什么InnoDB非主键索引普遍比主键索引要慢吗？”答案是InnoDB使用了聚簇索引，主键索引主需要查询一次，而非主键索引需要查询两次。  

为什么非主键索引需要查询两次呢？且看接下来的内容。

### 主索引与辅助索引
 
首先介绍一下基础的概念。在索引的分类中，我们可以按照索引的键是否为主键来分为“主索引”和“辅助索引”，使用主键键值建立的索引称为“主索引”，其它的称为“辅助索引”。因此主索引只能有一个，辅助索引可以有很多个。
为什么需要用到辅助索引？因为前面我们介绍了，查询语句如果想要使用索引，是需要满足最左匹配原则的。有时候我们的查询并不会使用到主键列，所以需要在其它列建立索引，即辅助索引。

 ### 非聚簇索引

非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。
非聚簇索引的数据表和索引表是分开存储的。非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。
### 聚簇索引

聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。因此主键的值长度越小越好，类型越简单越好。
聚簇索引的数据和主键索引存储在一起。
聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘I/O，加快查询速度。但是也是因为这个原因，聚簇索引的插入顺序最好按照主键单调的顺序插入，否则会频繁的引起页分裂（BTree插入时的一个操作），严重影响性能。
在InnoDB中，如果只需要查找索引的列，就尽量不要加入其它的列，这样会提高查询效率。
一张图说明聚簇索引与非聚簇索引的区别：

### 为什么要使用联合索引(将一个索引同时建立在说多个列上)
- 减少开销。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！
- 覆盖索引。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。
- 效率高。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！

### 最左前缀匹配原则


在mysql建立多列索引(联合索引)时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：
对列col1、列col2和列col3建一个联合索引

> KEY test_col1_col2_col3 on test(col1,col2,col3);
联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。
> SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”

#### 原因
1. b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。

2. 比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）
![](https://ws1.sinaimg.cn/large/007SLs93ly1g6dykflm4tj30p10ctq3o.jpg)



InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
![](https://ws1.sinaimg.cn/large/007SLs93ly1g6dzhyolooj30h909bt8w.jpg)

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。
![](https://ws1.sinaimg.cn/large/007SLs93ly1g6dzi5j49zj30g8080q31.jpg)


#### 哈希索引
哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

无法用于排序与分组；

只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找


## 事务的隔离级别

1. 读未提交(RU)

2. 读已提交(RC)

3. 可重复读(RR)

4. 串行

## 什么是事务
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。

## 如何查询第n高的工资？
SELECT DISTINCT(salary) from employee ORDER BY salary DESC LIMIT n-1,1

## explain
对SELECT语句分析，并输入执行的详细信息。  
使用：在SELECT语句前面加上Explain就行。

输入内容解析：
- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.

- select_type: SELECT 查询的类型.

- table: 查询的是哪个表

- partitions: 匹配的分区

- type: 查询类型 由好到慢 system > const > eq_ref > ref > range > index > ALL

- possible_keys: 此次查询中可能选用的索引

- key: 此次查询中确切使用到的索引.

- ref: 哪个字段或常数与 key 一起被使用

- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.

- filtered: 表示此查询条件所过滤的数据的百分比

- extra: 额外的信息


## 索引失效与优化
1. 全值匹配我最爱
2. 最佳左前缀法则(带头索引不能死，中间索引不能断)
3. 不要在索引上做任何操作(计算，函数，自动/手动类型转换)，这会导致索引失效转而全表扫描。
4. 减少使用select*
5. 索引字段上使用(!= 或者< >)判断时，会导致索引失效而转向全表扫描
6. 索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描
7. 索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描
8. 索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描
9. 索引字段使用 or 时，会导致索引失效而转向全表扫描

![](https://ws1.sinaimg.cn/large/007SLs93ly1g672t5xzkcj311n0fw44y.jpg)

![](https://ws1.sinaimg.cn/large/007SLs93ly1g672tlpkj8j309306a0ty.jpg)