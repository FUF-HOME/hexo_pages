# Java基础知识-基础语法
## 1. 基本数据类型
- byte（1字节）
- boolean (根据JVM分配，)
- char (2个字节)
- short(2 byte)
- int (4 byte)
- float (4 byte)
- long (8 byte)
- double (8 byte)

可以根据字节来记忆--- 1，2，4，8字节各两个。这样记忆得好处还能将取值范围记住。
1. 确定byte是1个字节，也就是8位,
2. 对于计算机而言，二进制最大的正数是01111111 转换成十进制为：127,也就是(2^7)-1
3. 最小的负数： 10000000，即-128。-> -(2^8)


> 二进制负数的值：取反一，所以 10000000 的值为：
    1. 取反 -> 01111111  127
    2. 加一  ->  128 
    3. 加上符号：  -128

这样 两个字节的范围就是[-(2^16),(2^15)]，依此类推。2的32次方，2的64次方。

---

## 2. 运算符

### 2.1  关系运算符
- &&运算符：仅在第一个条件为真时才评估下一个条件。 如果任何条件为假，则不会进一步评估该语句。

- ＆运算符：即使条件为假，它也会评估所有条件。 因此，仅在这种情况下才会反映由于条件引起的数据值的任何变化。

### 2.2 位运算符
> 注意 这里的0和1都是二进制的数，按照二进制的规则，与其他进制的规则有区别。

#### 2.2.1按位"与"运算符
＆运算符用于在Java中添加按位数字。 按位数字是以整数形式存储的二进制数字。
参加运算的两个数据，按二进制位进行“与”运算。

运算规则：
` 0&0=0;   0&1=0;    1&0=0;     1&1=1; `

**特殊运用**

1. 清零：一个二进制数与一个每位数都为0的二进制数相"与"，那得到的结果为零，及结果每位都是0。

2. 得到一个二进制数中指定值：假定一个二进制数 10101001，你想取该数的低四位，可以让 10101001 & 00001111 得到 00001001。


#### 2.2.2按位"或"运算符
运算规则：0|0=0；   0|1=1；   1|0=1；    1|1=1；

**特殊运作**
1. 将一个二进制数的某些为重置为1

    假定一个二进制数为 01101000 将低位全部重置为1，可以同 "或", 01101000 | 00001111 = 01101111.
#### 2.2.3 异或运算符（^）

运算规则：0^0=0；   0^1=1；   1^0=1；   1^1=0；
**特殊运用**
1. 使特定位翻转找一个数，对应X要翻转的各位，该数的对应位为1，其余位为零，此数与X对应位异或即可。
例：X=10101110，使X低4位翻转，用X ^ 0000 1111 = 1010 0001即可得到。
2. 与0相异或，保留原值 ，X ^ 0000 0000 = 1010 1110。

#### 2.2.4 取反运算符（~）
参加运算的一个数据，按二进制位进行“取反”运算。

运算规则：~1=0；   ~0=1； 在Java 实际测试中 你用

**特殊运用**
1. 使一个数的最低位为零，可以表示为：a&~1。
    ~1的值为1111111111111110，再按“与”运算，最低位一定为0。因为“~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

#### 2.2.5左移运算符（<<）
将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。
1. 例：a = a << 2 将a的二进制位左移2位，右补0，

    左移1位后a = a * 2; 

    若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。
#### 2.2.6右移运算符（>>）
将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。

操作数每右移一位，相当于该数除以2。

1. 例如：a = a >> 2 将a的二进制位右移2位，

    左补0 or 补1 得看被移数是正还是负。

#### 2.2.7 无符号右移运算符（>>>）
1. `>>>` 运算符把 expression1 的各个位向右移 expression2 指定的位数。右移后左边空出的位用零来填充。移出右边的位被丢弃。


#### 2.2.8 复合赋值运算符
位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：
```
&=    例：a &= b        相当于a=a & b

|=    例：a |= b        相当于a=a | b

>>=   例：a >>= b       相当于a=a >> b

<<= 例：a <<= b       相当于a=a << b

^=   例：a ^= b       相当于a=a ^ b
```
**运算规则**：和前面讲的复合赋值运算符的运算规则相似。


#### 2.2.9 不同长度的数据进行位运算
如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。

---






### 2.3 算数运算符






## 3. 表达式

## 4. 选择与循环语句
## 5. 类与对象
   1. 普通类
   2. 抽象类
   3. 接口
   4. 枚举
   5. Annotation
   6. 内部类

## 6. 继承与实现
### 联系
继承和接口都能实现代码重用，提高开发效率。体现了实物的传递性，继承关系达到复用的目的。
### 区别
1. 修饰不同：不同的修饰符修饰；实现：implements，继承：extends；
2. 数量不同：Java只支持“接口”的多继承,不支持“类”的多继承；而继承在java中具有单根性,子类只能继承一个父类。  
总结为：单继承，多实现。
3. 属性不同： 在接口中只能定义全局常量（static final）,和无实现的方法；而在继承中可以定义属性方法,变量,常量等...

4. 调用不同： 某个接口被类实现时,在类中一定要实现接口中的抽象方法；而继承想调用那个方法就调用那个方法,毫无压力


总结：
- 接口是对功能的描述(方法/行为)，接口传达的意思是：拥有某种功能，能干吗 比如：Serializable代表可序列化的。     
- 继承：什么是一种什么。继承传达的意思是：is-a比如 猫 是一个 动物。猫就是动物的子类。



## 7. 异常
### 7.1 类型
![异常的类型](../../hexo_pages/img/Exception.png)  
从上图足够帮助我们理解一些基础知识了。
- 所有的异常都是从Throwable继承而来。
- Throwable 有两个之类，Error 和 Exception。
- Error： 是对于编译时期的错误 以及系统错误。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况
- Exception：它规定的是程序本身可以处理的异常。异常和错误的区别是，异常可以被处理，而错误没法被处理。

- Checked Exception：可检查的异常，所有的checked exception 都是需要再代码中处理 的。它们的发生是可以预测的 
正常的一种情况，可以合理的处理。比如IOException，或者一些自定义的异常。除了RuntimeException及其子类以外，都是checked exception。

- Unchecked Exception：
RuntimeException及其子类都是unchecked exception。比如NPE空指针异常，除数为0的算数异常ArithmeticException等等，这种异常是运行时发生，无法预先捕捉处理的。Error也是unchecked exception，也是无法预先处理的。
### 7.2 异常的处理
1. 通过 try....catch 语句块来处理：
```
try{
    //程序代码
}catch(Exception e){
    // catch 块 
}
finally{

}
```
**这里需要提到一个点,关于 return 在此 语句块中的效果**
1. try 中 return ，会先执行 return 前的代码，然后保存需要 return 的信息，再执行finally 的代码，最后再通过 return 返回之前保存的信息。

2. catch 中 带有 return，与try相同，return 会先临时保存值。
3. finally 中带有 return，当finally中有 return的时候，try中的return会失效，在执行完finally的return之后，就不会再执行try中的return。这种写法，编译是可以编译通过的，但是编译器会给予警告，所以不推荐在finally中写return，这会破坏程序的完整性，而且一旦finally里出现异常，会导致catch中的异常被覆盖。  

**总结**
1. finally中的代码总会被执行。

2. 当try、catch中有return时，也会执行finally。return的时候，要注意返回值的类型，是否受到finally中代码的影响。

3. finally中有return时，会直接在finally中退出，导致try、catch中的return失效



## 8. package与jar包



## 9.  序列化与反序列
序列化（Serialization）是将对象的状态信息转化为可以存储或者传输的形式的过程，一般将一个对象存储到一个储存媒介，例如档案或记忆体缓冲等，在网络传输过程中，可以是字节或者XML等格式；而字节或者XML格式的可以还原成完全相等的对象，这个相反的过程又称为反序列化；

## 10.  正则表达式
定义一个搜索模式的字符串。它可以用于搜索，编辑和操作文本。

## 11. 重写和重载
### 11.1 重写(Override)
重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！  
重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。   
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常
### 重写规则
- 参数列表必须完全与被重写方法的相同。

- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。

- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。

- 父类的成员方法只能被它的子类重写。

- 声明为 final 的方法不能被重写。

- 声明为 static 的方法不能被重写，但是能够被再次声明。

- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。

- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。

- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。

- 构造方法不能被重写。

- 如果不能继承一个方法，则不能重写这个方法。
### Super 关键字的使用
需要在子类中调用父类的重写方法时，需要用 super 关键字。

## 11.2 重载(Overload)
重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

### 重载规则

-  被重载的方法必须改变参数列表(参数个数或类型不一样)。
-  被重载的方法可以改变返回类型，修饰符，可以声明新的或更广的检查异常。
-  方法能够再同一个类中或者一个子类中被重载。
-  无法以返回值类型作为重载函数的区分标准。
**总结：**
方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。


##  java虚拟机整数
在java虚拟机中整数有byte、short、int、long四种 分别表示 8位、16位、32位、64位有符号整数。整数使用补码表示。
> 为了简单起见，这里我们用1个字节来表示一个整数。

### 原码
所谓原码就是符号位加上数字的二进制表示，int为例，第一位表示符号 (0正数 1负数)。  

```
+10的原码：00001010
-10的原码：10001010  
```

**对于原码来说，绝对值相等的正数和负数只有符号位不同。**

### 反码
一个数如果为正，则它的反码与原码相同；一个数如果为负，则符号位为1，(符号位不变化，其余位数取反)。  
换言之 该数的绝对值取反(绝对值取反各位都取反)。  
```
     +10的反码为：00001010  
     -10的反码为：11110101
```

### 补码
**补码**：一个数如果为正，则它的原码、反码、补码相同；一个数如果为负，先计算反码然后加1。(反码加1就是补码)：

```
+10的补码为： 00001010
-10的补码为： 11110111
```

## 总结
### 1. 正数：它的原码、反码、补码相同。

### 2. 负数：反码符号位不变化，其余位数取反,补码符号位不变化其余各位原码取反(反码)+1。